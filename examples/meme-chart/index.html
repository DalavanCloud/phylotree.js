<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        font: 20px sans-serif;
    }
    
    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }
    
    .area {
        fill: #ddd;
        stroke: #444;
        stroke-width: 0.5px;
        fill-opacity: 0.33;
    }
    
    .line {
        fill: none;
        stroke: black;
        stroke-width: 0.5px;
    }

    .annotation-rect {
        fill: #999;
        stroke: none;
        fill-opacity: 0.5;
    }

    .annotation-text {
        font: 20px sans-serif;
        text-anchor: middle;
        fill: #333;
    }
    
</style>

<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script>
        var base_line = 20;

        var margin = {
                top: 40,
                right: 20,
                bottom: 3 * base_line,
                left: 2 * base_line
            },
            width = 1500 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;

        function plot_some_data(plot_data, title, container, splitter, y_domain, annotator, ratio) {
            /* 
                plot_data -- the FUBAR data to plot; generated by load_file 
                title -- the title of the plot
                container -- the DOM element where the SVG with this plot will go
                splitter -- NULL (single color plot/no legend), or an array of the form
                            [ filter function (on codon indices),
                              fill color,
                              stroke color]
                              
                annotator -- NULL (no region annotation), or an array of entries like this
                            [ start_codon, end_codon, y-coordinate, label, label above or below line ]
            */
            
        
            var x = d3.scale.linear()
                .range([0, width]);

            var y = (ratio ? d3.scale.pow().exponent (ratio) : d3.scale.linear())
                .range([height, 0]);
                

            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            /* step-plot generator*/

            var area = d3.svg.area()
                .x(function(d) {
                    return x(d.codon);
                })
                .y0(function(d) {
                    return y(0);
                })
                .y1(function(d) {
                    return y(d.value);
                }).
            interpolate('step');


            var svg = container.append("svg").style("display", "table-cell")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            
            /* set the domain for the codons */

            x.domain(d3.extent(plot_data, function(d) {
                return d.codon;
            })).clamp (true);

            /* set user-specified domain (for beta-alpha), 
               or auto-detect one*/
                
            if (y_domain) {
                y.domain (y_domain).clamp (true);
            } else {
                y.domain(d3.extent(plot_data, function(d) {
                    return d.value;
                }));
            
                var symmetrize = d3.min (y.domain().map (function (d) {return Math.abs (d);}))*1.25;
                y.domain ([-symmetrize,symmetrize]).clamp(true);
            }

            /* determine if the plot needs to be partitioned into regions 
               if so, draw a separate path for each block
            */

            if (splitter) {
            
                splitter.forEach(function(d) {
                    svg.append("path").datum(plot_data.filter(d[0]))
                        .attr("class", "area")
                        .attr("d", area)
                        .style("fill", d[1])
                        .style("stroke", d[2]);
                    
                });
            } else {
                svg.append("path")
                    .datum(plot_data)
                    .attr("class", "area")
                    .attr("d", area);
            }

            /* for points that have a p-value of 0.05 or less, 
               plot a circle on the x-axis 
            */    
            
            plot_data.forEach (function (d) {
                if (d.p <= 0.05) {
                    svg.append ("circle").attr ("cx", x(d.codon)).attr ("cy", y(0)).attr ("r", "5").append ("title").text ("Codon " + d.codon + " [p = " + d.p + "]");
                }
            });

 
            /* handle annotation is provided
            */
            
            if (annotator) {
                annotator.forEach(function(d) {
                    svg.append("rect")
                        .attr("class", "annotation-rect")
                        .attr("x", x(d[0]))
                        .attr("width", x(d[1])-x(d[0]))
                        .attr("y", y(d[2]))
                        .attr("height", base_line);

                    /*for (i = 0; i < 2; i++) {
                        svg.append("line")
                            .attr("class", "annotation-line")
                            .attr("x1", x(d[i]))
                            .attr("x2", x(d[i]))
                            .attr("y1", y(d[2])-5)
                            .attr("y2", y(d[2])+5);
                    }*/
                        
                    svg.append ("text")
                        .attr("class", "annotation-text")
                        .attr("x", x(d[4]))
                        .attr("y", y(d[2]) + base_line)
                        .attr("dy", "-.1em")
                        .text (d[3]);
                    
                });            
            }
           
             /* x-axis */
            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis)
                .append("text")
                .attr("x", width)
                .attr("dy", "+2.5em")
                .style("text-anchor", "end")
                .text("Codon");
                
            

           /* y-axis*/
            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", "0.75em")
                .style("text-anchor", "end")
                .text("E[\u03B2/\u03B1]"); // beta - alpha

            /* plot title */
            if (title) {
                svg.append("text").text(title).style("font-size", "24px").attr("dx", "2em").attr("dy", "-0.5em");
            }
        }
        
        
        function load_file(list, index) {
        
            function normalize_ratio (alpha, beta1, beta2, p) {
                beta1  = +beta1;
                beta2  = +beta2;
                p      = +p;
                alpha = +alpha;
                
                beta = beta1 * p + beta2 * (1-p);
                
                if (alpha == 0) {
                    if (beta == 0) {
                        return 1;
                    } 
                    return 100;
                }
                
                return beta/alpha;
            }
        
            d3.csv(list[index][0], function(error, data) {
                if (error) throw error;

                var data_to_plot = [];
                var container_div = d3.select("body").append("div");


                data_to_plot.push([list[index][0], data.map(function(d, index) {
                
                    //if (index == 0)
                    return {
                        "codon": index+1,
                        "value": normalize_ratio(d["Length_scaler"], d["beta1"], d["beta2"], d["weight1"]),
                        "p": +d["p-value"]
                   };
                })]);


                data_to_plot.forEach(function(d) {
                    plot_some_data(d[1], list[index][1], container_div, list[index][2], list[index][3], list[index][4], list[index][5]);
                });

                if (index + 1 < list.length) {
                    load_file(list, index + 1);
                }

            });
        }

        /* the first argument to load_file is an array with the following entries (arrays themselves)
            [ 
              URL for the file,
              label for the plot (can be null),
              plot splitter      (see plot_some_data),
              y-axis range       (can be null to auto-detect),
              annotator          (see plot_some_data, can be null)
            ]
        */
        
        load_file([
            ["dog.meme-internal.csv", "MEME test internal branches only", [
                [function(d) {
                    return d.codon <= 450;
                }, "#1f77b4", "#1f77b4"],
                [function(d) {
                    return d.codon > 450 && d.codon <= 743;
                }, "#d62728", "#d62728"],
                [function(d) {
                    return d.codon > 743 && d.codon <= 945;
                }, "#9467bd", "#9467bd"],
                 [function(d) {
                    return d.codon > 945 && d.codon <= 1469;
                }, "#ff7f0e", "#ff7f0e"],
                [function(d) {
                    return d.codon > 1469;
                }, "#2ca02c", "#2ca02c"]
            ],[0,100], 
            [[1,450,90,"N",225,true],
             [451,743,80,"P", (743+451)/2, true],
             [744,945,90,"M", (744+945)/2, true],
             [946,1469,80,"G", (1469+946)/2, true],
             [1470,3596,90,"L", (1470+3596)/2, true],
             ],
             0.5
            ],
            
           ["dog.meme.csv", "MEME test entire tree", [
                 [function(d) {
                    return d.codon <= 450;
                }, "#1f77b4", "#1f77b4"],
                [function(d) {
                    return d.codon > 450 && d.codon <= 743;
                }, "#d62728", "#d62728"],
                [function(d) {
                    return d.codon > 743 && d.codon <= 945;
                }, "#9467bd", "#9467bd"],
                 [function(d) {
                    return d.codon > 945 && d.codon <= 1469;
                }, "#ff7f0e", "#ff7f0e"],
                [function(d) {
                    return d.codon > 1469;
                }, "#2ca02c", "#2ca02c"]
            ],[0,100], 
            [[1,450,90,"N",225,true],
             [451,743,80,"P", (743+451)/2, true],
             [744,945,90,"M", (744+945)/2, true],
             [946,1469,80,"G", (1469+946)/2, true],
             [1470,3596,90,"L", (1470+3596)/2, true],
             ],

             0.5
            ],
        ], 0);

        //d3.json("coverages-csf.json", function(error, data) {
    </script>
